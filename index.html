<html>
<head>
	<title>Point Location</title>
	<!-- <link rel="stylesheet" type="text/css" href="main.css" /> -->
	<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script> -->
	<!-- <script type="text/javascript"
	  src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script> -->
	<script type="text/javascript"
	  src="./LaTeXMathML.js">
	</script>
</head>

<body>
	<h1>Point Location in Dynamic Planar Subdivisions</h1>
	<div style="max-width: 900">
	<p>
		This webpage serves as a detailed overview of Oh and Ahn's data structure toward a fully dynamic point location algorithm. The method of Oh and Ahn achieves achieve an update time of $O(\sqrt{n}logn{(loglogn)}^{3/2})$ and a query time of $O(logn{(loglogn)}^2)$, where $n$ is the number of edges in the subdivisions. When the user is restricted to only deleting edges from the initial subdivision, their method provides $O(\alpha(n))$ update time and $O(logn)$ query time, where $\alpha()$ is the inverse ackerman function.
	</p>
	<h2> Contents </h2>
		<ul> 
			<li> Background </li>
			<li> Data Structure Overview </li>
			<li> More Stuff </li>
			<li> Other Stuff </li>
		</ul>
	<h2> Background </h2>
		<p>
			Given a set of non-intersecting edges that subdivide the plane into non-overlapping faces, the goal is to design a dynamic data structure that can support the operation $locate(x)$ in which the user provides a query point $x$ in the plane, and the face containing $x$ is reported to the user. Note that the subdivision need not be connected, provided that there are no intersecting edges. <b> FIGURE NEEDED </b>
		</p>
		<p>
			The fundamental terminology relevant to the dynamic approach is largely the same as that of the static approach. There are, however, some basic concepts that are novel and essential to understanding the method of Oh and Ahn.
		</p>
		<p>
			<b>Half-edges.</b> Every edge in the subdivision is considered to be comprised of two directed edges oriented such that the face incident to the half-edge lies to its left relative to its direction. Note that while edges are considered to be comprised of two half-edges, all operations concerning edges (Remove, Insert) involve the whole, indivisible edge. <b> FIGURE NEEDED </b>
		</p>
		<p>
			<b>Outer/Inner Boundaries.</b> The presence of half-edges motivates a more concrete distinction for the different kinds of boundaries a face in the subdivision can have. An <i> Outer Boundary </i> is the component defining the boundary of a face, $F$, such that $F$ is incident to the half-edges traversable in a counter-clockwise orientation. Every other connected component incident to $F$ is called an <i>Inner Boundary</i>. <b> FIGURE NEEDED </b>
		</p>
		<p>
			<b>Edge types.</b> All edges are said to be in one of three states: Old, Communal, and New. The exact way in which edges change types will be explained in the update algorithms.
		</p>
	<h2> Data Structure Overview </h2>
		<p> 
			The data structure, $D$, used to resolve queries is comprised of two data structures, one containing Old and Communal edges, $D_o$, and the other containing New and Communal edges, $D_n$. The update and query protocols for each data structure will be explained in turn.
		</p>
		<h3> Semi-Dynamic Data Structure </h3>
			<p>
				The data structure described in this section is only semi-dynamic insofar as it supports only $delete(e)$ (where $e$ is an edge in the subdivision) and $locate(x)$. The mechanics of this data structure will be explained here and its use in the fully dynamic solution will be explained later.
			</p>
			<p> 
				The semi-dynamic data structure itself consists of two components: a <b>static point location data structure</b>, which keeps track of the initial subdivision, and a <b>disjoint-set</b> of faces which keeps track the current faces in the subdivision as edges are deleted. In the static subdivison, the $m$ faces are uniquely identifiable with names $1 ... m$ (note: $m$ is $O(n)$ as this is a planar subdivision). The face identifiers are stored in a disjoint-set data structure, $S$. The mechanics of $S$ are such that two faces are in the same set if and only if the two faces have been merged into one face. As faces is in this initial subdivision do not overlap, every face in $S$ is a singleton set. An edge set containing all of the edges in the subdivision is maintained such that every every edge points to its incident face(s).
			</p>
			<p>
				When $delete(e)$ is processed, find the incident faces to $e$ in the <b>static</b> subdivision in $O(1)$ time. If $e$ is incident to two faces, $A$ and $B$, find the sets in $S$ containing $A$ and $B$. If they are in separate sets, they are merged into one set all in $O(\alpha(n))$ time. The root in $S$ corresponding to this new, merged set is given a new unique name. If the two faces are already in the same set in $S$, no change is needed. Maintaining the disjoint set in this way ensures that there is a one-to-one correspondence between the number of faces in the current subdivision and the number of disjoint sets in $S$.
			</p>
			<p>
				To resolve a $locate(x)$ query, simply resolve $locate(x)$ in the static subdivision in $O(logn)$ (let result be $F$), find the subset in $S$ that contains $F$ in $O(\alpha(n))$, and report this subset.
			</p>
			<p>
				<b>Key Takeaways:</b> A semi-dynamic data structure that only supports $delete(e)$ and $locate(x)$ can be achieved by simultaneously maintaining the initial static point location data structure and a disjoint-set of current faces. With $O(nlogn)$ preprocessing time to form the static data structure and $O(\alpha(n))$ update time, $O(logn)$ query time is achieved.
			</p>
		<h3> Fully Dynamic Data Structure </h3>
		<p>
			As noted, the fully dynamic point location data structure consists of two sub data structures, $D_o$ and $D_n$. For the rest of the explanation, $E_o$ and $E_n$ will refer to the set of old + communal edges and communal + new edges, respectively, and $M_o$ and $M_n$ will refer to the subdivisions induced by the corresponding edge sets. $D_o$ is thus the data structure maintaing $E_o$ and $D_n$ is the data structure maintaining $E_n$. $D_o$ is implemented as the semi-dynamic data structure explained above. This section will focus more on the mechanics $D_n$ toward a fully-dynamic data structure, and explain how edges change types.
		</p>
		<p>
			<b> Structure.</b> The dynamic data structure underlying $D_n$ needs to support verticle ray-shooting queries for $E_n$. The method of Oh and Ahn uses the data structure by Chan and Nekrich which achieves an update time of $O(lognloglogn)$ and a query time of $O(logn{(loglogn)}^{2}$). Also, each component of the boundary of each face in $M_n$ is stored in a concatenable queue. This queue supports insertion, deletion, splitting the queue into two, and merging two queus into one. The edges for a given boundary component can thus be accesed sequentially as they appear in the boundary, and the queues for each boundary component can be merged so the boundary components for $M_n$ can be traversed. By implementing the queue with a 2-3 tree, all operations are supported in $O(logn)$ time where $n$ is the number of elements in the queue. The organization of this queue is briefly described as follows:
			<ul>
				<li> Choose an element of the queue, make this the root of the 2-3 tree (and thus the way to access the elements of the queue) </li>
				<li> If the queue represents an outer boundary of $F$, make the root point to the roots of all inner boundaries of $F$ </li>
				<li> If the queue represents an inner boundary of $F$, make the root point to the root of the corresponding outer boundary of $F$ </li>
			</ul>
			Note that since a given edge can be incident to at most two faces, that edge will be stored twice in the queue as a boundary components for the two incident faces. Also, every edge in $E_n$ points to the corresponding element(s) in the queue.
		</p>
		<p>
			The vertices in $M_n$ are maintained in a balanced BST so that there can be a check if a point in the plane is a vertex of $M_n$ in $O(logn)$. Additionally, for every vertex, th edges in $M_n$ adjacent to it are stored in BST in clockwise order around the vertex.
		</p>
		<b><i> NOTE TO SELF: The root of the queue representing the entire subdivision could be outer face of the subdivision to which everything is an inner boundary. This allows a mechanism to systematically access every face's particular queue. The paper doesn't say this so maybe it isn't necessary (or is assumed to be obvious) </i></b>
		<p>
			<b> Mechanics.</b> Initially, every edge is set to old, so $D_n$ is empty. When $insert(e)$ is executed, the one face, $F$, in $M_o$ that $e$ intersects is found. All edges on the <b>outer</b> boundary of $F$ are set to communal. If $e$ is inserted such that it connects the outer boundary of $F$ to an inner boundary of $F$, then the edges on the inner boundary are set to communal as well. The new edge that is inserted is set to new. Notice that after this insertion, $D_n$ is always populated with at least $e$ and the outer boundary of $F$, and it may also be populated with a certain inner boundary of $F$ if the condition above is met. Similarly, when $delete(e)$ is executed, the outer boundary of the face(s) incident to $e$ is set to communal. 
		</p>
	</div>
</body>
</html>